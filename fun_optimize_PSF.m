function [a_opt, fval]=fun_optimize_PSF(PSF,lens,cam,E_tensor,pupilmask,Z,a_ini,sig,bg,varargin)
%find optimal pupil phase based on a CRLB-based metric
%PSF...3D point spread function, member of "psf" class
%lens...member of "objective" class
%cam...member of the "camera" class
%E_tensor...tensor with size [Nkx, Nky, nz, 6], containing BFP field generated by
%the 3 dipoles (x,y,z) in the focal plane: Ex_Px, Ex_Py, Ex_Pz, Ey_Px, Ey_Py,Ey_Pz
%pupilmask...size [nx,ny], contains additional pupil apodization or phase masks
%Z...stack of Zernikes that are varied during optimization 
%sig...no. of signal photons contained in the PSF
%bg...no. of background photons per pixel
%---------------------------------------------------------

%handling optional input arguments
%1st optional argument: metric-type
%2nd optoinal argument: biplane / single channel
%3rd optional argument: pupil mask for Donald imaging, only if "donald" is
%chosen for method
nVarargs=length(varargin); 

if nVarargs==1
    metrictype=varargin{1};
    method='';
    pupil_UAF=1;
    norm_method = 'uaf';   
elseif nVarargs==2
    metrictype=varargin{1};
    method=varargin{2}; 
    pupil_UAF=1; 
    norm_method = 'uaf';   
elseif nVarargs==3
    metrictype=varargin{1};
    method=varargin{2};
    pupil_UAF=varargin{3}; %for Donald imaging
    norm_method = 'uaf';   
elseif nVarargs==4
    metrictype=varargin{1};
    method=varargin{2};
    pupil_UAF=varargin{3}; %for Donald imaging
    norm_method = varargin{4}; %method of normalization (const. intensity in uaf+saf or only uaf)
else
    metrictype=1; 
    method='';
    pupil_UAF=1; 
    norm_method = 'uaf';  
end

%------------------------------

%create PSF-object that is NOT oversampled
PSF2=PSF;
PSF2.os=1;
PSF2.ux=PSF.ux*PSF.os;
PSF2.Nx=PSF.Nx/PSF.os; 
PSF2.Ny=PSF.Ny/PSF.os; 
PSF2.data=zeros(PSF2.Nx,PSF2.Nx,PSF2.Nz);

if strcmp(method,'biplane') || strcmp(method,'donald') || strcmp(method,'dSALM')
    PSF3=PSF2; 
end

Ex_Px=E_tensor(:,:,:,1); 
Ex_Py=E_tensor(:,:,:,2); 
Ex_Pz=E_tensor(:,:,:,3); 
Ey_Px=E_tensor(:,:,:,4); 
Ey_Py=E_tensor(:,:,:,5); 
Ey_Pz=E_tensor(:,:,:,6); 

%Method of normalization 
if strcmp(norm_method,'tot')
    %normalization for a constant number of photons in ENTIRE pupil (UAF + SAF)
    E_tot=squeeze(abs(pupilmask).^2.*sum(sum(sum(abs(E_tensor).^2,1),2),4));
elseif strcmp(norm_method,'uaf')
    %normalization for a constant number of photons in UAF pupil (more
    %realistic)
    E_tot=squeeze(abs(pupilmask).^2.*sum(sum(sum(abs(E_tensor.*pupil_UAF).^2,1),2),4));
end

Nk=size(Ex_Px,1);
uk=4*pi/PSF.lambda*lens.NA/Nk; %unit in pupil space (k-space)
z=(0:PSF2.Nz-1)*PSF.uz*1e9; %for display purposes only
norm=0; %normalize PSF? 

options=optimset('Display','iter','Tolfun',1e-7);

%preparations for CZT2_fast.m
    ux_fft=2*pi/(Nk*uk); %fft resolution without padding
    r=PSF2.ux/ux_fft; %required r-factor to meet the desired resolution at the given grid size N
    alpha=r*1/Nk;
    N_pad=PSF2.Nx+Nk-0;
    x=(floor(-N_pad(1)/2+0.5):floor(N_pad(1)/2-0.5))';
    y=(floor(-N_pad(1)/2+0.5):floor(N_pad(1)/2-0.5));
    kernel=exp(-1i*alpha*pi*x.^2)*exp(-1i*alpha*pi*y.^2); %create quadratic convolution phase kernel; faster method
    F_kernel=fft2(ifftshift(kernel)); 


if strcmp(method,'biplane') || strcmp(method,'donald') || strcmp(method,'dSALM')
    
    if length(a_ini)==3 %if the split-ratio (parameter 3) is also variable
        LB=[-10, -10, 0]; %it is important to bound the split ratio!
        UB=[10, 10, 1]; 
        [a_opt, fval]=fminsearchbnd(@fun_optimize_biplane,a_ini,LB,UB,options);
    else
        [a_opt, fval]=fminsearch(@fun_optimize_biplane,a_ini,options);
    end
    
else %single-channel imaging
    [a_opt, fval]=fminsearch(@fun_optimize,a_ini,options);
end


%% ------------------------------SINGLE CHANNEL IMAGING------------------------------

function metric=fun_optimize(a)
    
    a2=ones(1,1,length(a)); a2(1,1,:)=a; 
    phase=sum(Z.*a2,3); 
    mask=pupilmask.*exp(1i*phase); 

    %calculate irradiance on camera, based on BFP fields and pupil phase
    for m=1:PSF.Nz
        %I_xx=abs(czt2(Ex_Px(:,:,m).*mask,uk,PSF2.ux,PSF2.Nx)).^2;
      
        I_xx=abs(czt2_fast(Ex_Px(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yx=abs(czt2_fast(Ey_Px(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_xy=abs(czt2_fast(Ex_Py(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yy=abs(czt2_fast(Ey_Py(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;   
        I_xz=abs(czt2_fast(Ex_Pz(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yz=abs(czt2_fast(Ey_Pz(:,:,m).*mask,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        PSF2.data(:,:,m)=(I_xx+I_yx+I_xy+I_yy+I_xz+I_yz)/E_tot(m);
    end
    
    [CRBx,CRBy,CRBz]=PSF2.CRLB(sig,bg,cam); 
    if metrictype==1
        metric=mean((sqrt((CRBx.*CRBy.*CRBz)).^(1/3)));  %"localization volume"
    elseif metrictype==2
        metric=mean((sqrt(abs(CRBz)))); 
    end

    %show pupil phase
    figure(1);
    %subplot(2,1,1);
    imagesc(phase); axis equal; axis tight; colorbar; 
    set(gca,'xtick',[]);
    set(gca,'ytick',[]);
    title('pupil phase'); 
    
    %show CRLB
    figure(2); 
    %subplot(2,1,2); 
    plot(z,sqrt(CRBx),'b');
    hold on; 
    plot(z,sqrt(CRBy),'b');
    plot(z,sqrt(CRBz),'r');
    hold off; 
    ylabel('nm');
    xlabel('z');    
    title([method ', ' num2str(a,3) ' / sig,bg=' num2str(sig) ',' num2str(bg)]);
    ylim([0 inf]);
    grid on; 
    pause(0);
    
end

%% ----------------------------------BIPLANE-------------------------------

function metric=fun_optimize_biplane(a)
    
    %the two input parameters a(1) and a(2) contain defocus values for the
    %two imaging channels, the third (optional) parameter, the split ratio
    %between the channels
    
    if strcmp(method,'biplane')
        eta = 0.5; 
        bg1 = bg; 
        bg2 = bg; 
        %defining differences between the two channels: 
        if length(a)>=4 %if other modes have been chosen, too
            phase1=a(1)*Z(:,:,1)+a(4)*Z(:,:,2);
            mask1=pupilmask.*exp(1i*phase1); 
            phase2=a(2)*Z(:,:,1)+a(5)*Z(:,:,3);
            mask2=pupilmask.*exp(1i*phase2); 
        else %pure biplane imaging, without additional Zernike modes    
            phase1=a(1)*Z(:,:,1);
            mask1=pupilmask.*exp(1i*phase1); 
            phase2=a(2)*Z(:,:,1);
            mask2=pupilmask.*exp(1i*phase2); 
        end
        
    elseif strcmp(method,'donald')
        eta = 0.5; 
        bg1 = bg; 
        bg2 = bg; 
        phase1=a(1)*Z(:,:,1);
        phase2=phase1; %a(2)*Z(:,:,2); 
        mask1=pupilmask.*exp(1i*phase1); 
        mask2=pupilmask.*pupil_UAF.*exp(1i*phase2);
        
    elseif strcmp(method,'dSALM')
        eta = 1;
        bg1 = bg; 
        bg2 = bg/10; %SAF channel is supposed to contain only a fraction of the background
        phase1=a(1)*Z(:,:,1);
        phase2=a(1)*Z(:,:,1); 
        mask1=pupilmask.*pupil_UAF.*exp(1i*phase1); %UAF channel
        mask2=pupilmask.*(1-pupil_UAF).*exp(1i*phase2); %SAF channel
         
    end
            
    if length(a)>=3  
        split_ratio=a(3);
    else
        split_ratio=0.5; 
    end
    
    %first channel PSF
    for m=1:PSF2.Nz
        I_xx=abs(czt2_fast(Ex_Px(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yx=abs(czt2_fast(Ey_Px(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_xy=abs(czt2_fast(Ex_Py(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yy=abs(czt2_fast(Ey_Py(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;   
        I_xz=abs(czt2_fast(Ex_Pz(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yz=abs(czt2_fast(Ey_Pz(:,:,m).*mask1,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        PSF2.data(:,:,m)=(I_xx+I_yx+I_xy+I_yy+I_xz+I_yz)/E_tot(m);
        %PSF2.data(:,:,m)=PSF2.data(:,:,m)/squeeze(sum(sum((I_xx+I_yx+I_xy+I_yy+I_xz+I_yz),1),2));
    end
    
    %second channel PSF
    for m=1:PSF3.Nz
        I_xx=abs(czt2_fast(Ex_Px(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yx=abs(czt2_fast(Ey_Px(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_xy=abs(czt2_fast(Ex_Py(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yy=abs(czt2_fast(Ey_Py(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;   
        I_xz=abs(czt2_fast(Ex_Pz(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        I_yz=abs(czt2_fast(Ey_Pz(:,:,m).*mask2,PSF2.Nx,N_pad,alpha,kernel,F_kernel)).^2;
        PSF3.data(:,:,m)=(I_xx+I_yx+I_xy+I_yy+I_xz+I_yz)/E_tot(m);
        %PSF3.data(:,:,m)=PSF3.data(:,:,m)/squeeze(sum(sum((I_xx+I_yx+I_xy+I_yy+I_xz+I_yz),1),2));
    end
    
    %---method B---: 
%     PSFdual = PSF2; 
%     PSFdual.data = [PSF2.data, PSF3.data]; 
%     PSFdual.Ny = 2*PSF2.Ny; 
%     [CRBx,CRBy,CRBz,~,~,~]=PSFdual.CRLB(sig,bg,cam,eta); 

    %---method C---: 
    [CRBx, CRBy, CRBz, ~, ~] = fun_CRLB({PSF2, PSF3},eta*sig,eta*[bg1 bg2],cam.readnoise); 

    if metrictype==1
        metric=mean((sqrt((CRBx.*CRBy.*CRBz)).^(1/3)));  %"localization volume"
    elseif metrictype==2
        metric=mean((sqrt(abs(CRBz)))); 
    end
    
    figure(1);
    subplot(2,1,1);
    imagesc(phase1); axis equal; axis tight; colorbar; 
    title('phase pupil 1'); 
    set(gca,'xtick',[]);
    set(gca,'ytick',[]);

    subplot(2,1,2);
    imagesc(phase2); axis equal; axis tight; colorbar; 
    title('phase pupil 2');
    set(gca,'xtick',[]);
    set(gca,'ytick',[]);

    figure(2); 
    plot(z,sqrt(CRBx),'b');
    hold on; 
    plot(z,sqrt(CRBy),'b');
    plot(z,sqrt(CRBz),'r');
    hold off; 
    ylabel('nm');
    xlabel('z');
    if strcmp(method,'dSALM')
        title([method ', ' num2str(a,3) ' / sig,bg=' num2str(sig) ',' num2str(bg1) '/' num2str(bg2)]);
    else
        title([method ', ' num2str(a,3) ' / sig,bg=' num2str(sig) ',' num2str(bg)]);
    end
    ylim([0 inf]);
    pause(0);
end

function E_out=czt2_fast(E_in,Nx,N_pad,alpha,kernel,F_kernel)
    %fast version of 2D chirped z-trafo;
    %important parameters such as kernel,etc. are passed to the function

    conj_kernel=conj(kernel);
    f1=embed(E_in,[N_pad,N_pad,size(E_in,3)],0).*conj_kernel;

    %convolving f1 and f2
    coefs_phase=conj_kernel.*fftshift(ifft2(fft2(ifftshift(f1)).*F_kernel))*alpha;
    E_out=embed(coefs_phase,[Nx,Nx,size(coefs_phase,3)],0); 
end

end

